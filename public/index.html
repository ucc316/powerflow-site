<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Power Flow Map</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <style>
    body { margin:0; font-family:system-ui,Arial,sans-serif }
    #topbar{display:flex;gap:16px;align-items:center;padding:10px 14px;border-bottom:1px solid #eee}
    .badge{display:inline-block;padding:.2rem .5rem;border-radius:.5rem;background:#f2f2f2}
    #map{width:100vw;height:calc(100vh - 52px)}
    .legend{display:flex;gap:10px;align-items:center}
    .sw{width:18px;height:6px;border-radius:3px;display:inline-block}
  </style>
</head>
<body>
  <div id="topbar">
    <strong>送電線の最新データ</strong>
    <span>更新: <span id="ts" class="badge">読み込み中...</span></span>
    <span>最大使用率: <b id="max">-</b></span>
    <div class="legend">
      <span class="sw" style="background:#2ecc71"></span><small>低</small>
      <span class="sw" style="background:#f1c40f"></span><small>中</small>
      <span class="sw" style="background:#f39c12"></span><small>高</small>
      <span class="sw" style="background:#e74c3c"></span><small> >100%</small>
    </div>
  </div>
  <div id="map"></div>

  <script>
    // ====== 設定 ======
    const MAP_STYLE   = "https://demotiles.maplibre.org/style.json"; // デモ用スタイル
    const GEOJSON_URL = "/geometry/lines.geojson";
    const DATA_URL    = "/data/latest.json";

    const SOURCE_ID   = "grid-lines";
    const LAYER_BASE  = "grid-base";
    const LAYER_FLOW  = "grid-flow";
    const LAYER_ARROW = "grid-arrows";

    // util(0-1) → 色
    const utilColor = [
      "case",
      [">", ["feature-state","util"], 1], "#e74c3c",
      ["interpolate", ["linear"], ["feature-state","util"],
        0, "#2ecc71", 0.5, "#f1c40f", 0.8, "#f39c12", 1.0, "#e67e22"
      ]
    ];
    // capacity(MW) → 太さ(px)
    const widthByCap = ["interpolate", ["linear"], ["to-number", ["get","capacity_mw"]],
      300, 2, 600, 4, 1200, 8, 2000, 10
    ];
    // ダッシュアニメ（ant path風）
    const dashSeq = [[0,4,3,2],[1,4,2,2],[2,4,1,2],[3,4,0,2]];
    let dashStep = 0;

    // ====== 地図初期化 ======
    const map = new maplibregl.Map({
      container: "map",
      style: MAP_STYLE,
      center: [139.75, 35.68], // 仮：関東付近
      zoom: 7
    });
    map.addControl(new maplibregl.NavigationControl(), "top-right");

    const featuresIndex = {}; // lineId の存在チェック用

    // ====== ここからご指定のブロック（+補助関数を下に定義） ======
<script>
  // 事前にこの定数はそのまま: MAP_STYLE, GEOJSON_URL, DATA_URL, SOURCE_ID, LAYER_BASE, LAYER_FLOW, LAYER_ARROW
  // そして utilColor / widthByCap / dashSeq / dashStep / map / featuresIndex も既にある前提

  // ① GeoJSONの読み込み→ソース追加→範囲に自動ズーム→ベース線だけまず描画
  map.on("load", async () => {
    try {
      const res = await fetch(GEOJSON_URL + "?cb=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error(`GeoJSON HTTP ${res.status}`);
      const geo = await res.json();

      if (!geo || !Array.isArray(geo.features) || geo.features.length === 0) {
        throw new Error("Feature が空です");
      }
      // lineId の存在チェック（表示には必須ではないが後の feature-state に必要）
      geo.features.forEach(f => {
        if (f?.properties?.lineId) featuresIndex[f.properties.lineId] = true;
      });

      map.addSource(SOURCE_ID, {
        type: "geojson",
        data: geo,
        promoteId: "lineId" // lineId が無い要素があっても描画はされます
      });

      // まず「絶対に見える」ようにベース線だけ表示
      map.addLayer({
        id: LAYER_BASE, type: "line", source: SOURCE_ID,
        paint: { "line-color": "#666", "line-width": 3, "line-opacity": 0.9 }
      });

      // ② 画面外にある可能性に備えて全体にフィット
      const bounds = bboxOfLines(geo);
      if (bounds) map.fitBounds(bounds, { padding: 40, duration: 0 });

      // ③ 本番用の色分けレイヤ & 矢印を追加
      map.addLayer({
        id: LAYER_FLOW, type: "line", source: SOURCE_ID,
        paint: {
          "line-color": utilColor,
          "line-width": widthByCap,
          "line-opacity": 0.95,
          "line-dasharray": dashSeq[dashStep],
          "line-cap": "round", "line-join": "round"
        }
      });

      map.addLayer({
        id: LAYER_ARROW, type: "symbol", source: SOURCE_ID,
        layout: {
          "symbol-placement": "line",
          "text-field": ["case", ["<", ["feature-state","dir"], 0], "◀", "▶"],
          "text-size": 14, "symbol-spacing": 80, "text-keep-upright": false
        },
        paint: { "text-color": utilColor, "text-opacity": 0.9 }
      });

      // ④ データを反映 & アニメ開始
      await applyLatest();
      setInterval(applyLatest, 60 * 1000);
      animateDash();
      console.log("GeoJSON loaded. features:", geo.features.length);

    } catch (err) {
      console.error("GeoJSON 読み込みエラー:", err);
      alert("GeoJSON を読み込めませんでした: " + err.message +
            "\n/geometry/lines.geojson をブラウザで直接開けるか確認してください。");
    }
  });

  // GeoJSON(LineString/MultiLineString)のバウンディングボックスを返す
  function bboxOfLines(fc) {
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for (const f of fc.features) {
      const g = f.geometry;
      if (!g) continue;
      if (g.type === "LineString") {
        for (const c of g.coordinates) {
          const [x,y] = c; // 必ず [経度, 緯度]！
          if (x<minX) minX=x; if (y<minY) minY=y;
          if (x>maxX) maxX=x; if (y>maxY) maxY=y;
        }
      } else if (g.type === "MultiLineString") {
        for (const line of g.coordinates) {
          for (const c of line) {
            const [x,y] = c;
            if (x<minX) minX=x; if (y<minY) minY=y;
            if (x>maxX) maxX=x; if (y>maxY) maxY=y;
          }
        }
      }
    }
    if (!isFinite(minX)) return null;
    return [[minX, minY], [maxX, maxY]];
  }
</script>

</body>
</html>
